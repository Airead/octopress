---
layout: post
title: "RSA 简介及 nodejs ursa 模块的使用"
date: 2014-01-01 23:14
comments: true
categories: nodejs
---

本文首先简单介绍一下非对称加密 RSA 的原理及应用，然后使用 nodejs 的 ursa 模块实现了这些应有场景。

## RSA 简介
一说到数据的加密，常常会涉及到这几个单词：算法、原文、密文和密钥。通常，发送者把原文通过一个加密的算法，用密钥进行加密后将密文发送给接收者，然后接收者再用密钥对密文进行解密，得到原文。由于常用的加密算法都是公开的，所以，对原文的加密的关键，就是密钥了。对于这种加解密都使用同样的密钥的算法，我们称之为对称加密，对称加密的代表算法就是DES家族了。那么这种对称加密有什么缺陷呢？由于加解密使用相同的密钥，那么这个密钥最少要保存在两个地方，如果加密的数据要发给多人，那么就会有更多的人知道密钥，这大大增加了密钥泄露的风险；并且密钥需要由发送方传递给接收方，那么如何保证密钥的传递的安全，则成了另外一个头疼的事情。为了解决这个问题，相对于对称加密，又出现了非对称加密。

什么是非对称加密？所谓的非对称加密，就是指加密和解密使用不同的密钥的一类加密算法。这类加密算法通常有两个密钥A和B，使用密钥A加密数据得到的密文，只有密钥B可以进行解密操作（即使密钥A也无法解密），相反，使用了密钥B加密数据得到的密文，只有密钥A可以解密。这两个密钥分别称为私钥和公钥，顾名思义，私钥就是你个人保留，不能公开的密钥，而公钥则是公开给加解密操作的另一方的。根据不同用途，对数据进行加密所使用的密钥也不相同（有时用公钥加密，私钥解密；有时相反用私钥加密，公钥解密）。非对称加密的代表算法是RSA算法。

那么非对称加密到底有哪些用途？

## RSA 的应用
### 数据加密
请大家想象一下，如果我不想让除了接收方以外的其他人，知道我发送的数据的内容的话，需要用哪种密钥对数据进行加密？如果我使用私钥加密，那么根据非对称加密的原理，接收方需要使用公钥来解密，而公钥我已经公开给接收方了，这个方案似乎是可行的，可是这样做问题就出现在公钥上了。在非对称加密中，公钥的公开不仅仅指对接收方的公开，而是指这个密钥彻底的公开，任何人需要都可以得到，这样的话你发送的数据就没有任何秘密可言了。反过来，如果我使用公钥对数据加密，那么对于接收方来说就需要使用私钥进行数据解密，由于私钥只保存在接收方手中，这样其他人就不会得到数据的内容了。这样看来，在非对称加密中，如果需要保护你的数据不被第三者得到，密钥需要由接收方产生，然后接收方将公钥公开出去，发送方使用这个公开的公钥对数据进行加密后传输给接收方，接收方使用自己的私钥进行解密，从而保证了数据的安全性。所以非对称加密又称为公钥加密。

非对称加密的执行效率要远低于对称加密，所以我们不会对一个大的文件或数据使用非对加密算法。那么我们如何加密一个大的文件呢？通常情况我们可以选择对称加密算法加密文件，然后使用非对称算法加密对称算法的密钥，这样就保证了对称算法密钥传递的安全性。

### 数字签名
什么是数字签名？数字签名同我们在合同上的签字一样，接收方可以用它来证明收到的数据或文件是由你发送的。举个例子：假设发送方需要将一串数据D发送给接收方，那么接收方如何判断数据D是发送方发送的呢？

    Step 1：发送方先产生成一对密钥，并将公钥公开给接收方；
    
    Step 2：发送方将数据D用私钥进行加密得到密文M，然后将数据D和密文M一起发送给接收方；
    
    Step 3：接收方得到数据D和密文M后，用公钥将密文M解密得到d；
    
    Step 4：比较D和d，相等则证明D是由发送方发送的。

在实际的操作中，我们并不会直接用私钥去加密要发送的数据或文件，这是因为非对称加密的算法非常耗时并且密文的长度要大于明文的长度，直接加密系统的开销非常大。那么如何实解决这个问题呢？

首先，我们需要了解另外一个概念：消息摘要。所谓的消息摘要就是通过一种单向算法计算出来的唯一对应一个文件或数据的固定长度的值，也被称作数字摘要。根据不同的算法，消息摘要的长度一般为128位或160位。常用的消息摘要的算法有MD5和SHA1。一个文件的消息摘要就同一个人的指纹一样，它可以唯一代表这个文件，如果这个文件被修改了，那么它的消息摘要也一定会发生变化，所以，我们可以通过对一个文件的消息摘要进行签名来代替对它本身进行签名。并且，我们还可以通过验证消息摘要，来确定发送的数据是否完整或曾经被修改过。这样，上面的例子大致可以变为下面这样：

    Step 1：发送方先产生成一对密钥，并将公钥公开给接收方；
    
    Step 2：发送方将数据D进行消息摘要，得到Q；
    
    Step 3：用私钥对Q进行加密得到密文MQ，然后将数据D和密文MQ一起发送给接收方；
    
    Step 4：接收方得到数据D和密文MQ后，用公钥将密文MQ解密得到q1；
    
    Step 5：接收方使用相同的算法对数据D进行消息摘要，得到q2；
    
    Step 6：比较q1和q2，相等则证明D是由发送方发送的，且没有被修改过。

好了，非对称加密的使用介绍了一大堆，接下来按照不同的场景使用 ursa 实现

## 场景及实现
假设 A，B 为两个人。
### 1. B收到信息，并且需要确认收到的信息来自于A
模拟步骤：
  1. A将信息 `Hello AireadFan` 通过A私钥加密，这时该信息只有拥有A公钥的人才能解密查看；
  2. B收到加密信息后，用A公钥解密，得到 `Hello AireadFan`，这样就可以确定该信息真的来自于A。
  
### 2. B发信息只想给A看，其它任何人都看不了
模拟步骤：
  1. B将信息 `Hello AireadFan` 通过A的公钥加密，这时该信息只有拥有A私钥的人才能解密查看；
  2. A收到加密信息后，用A私钥解密获取信息。

### 3. B需要接收大量信息，并确认收到的信息来自于A
  1. A将大量信息M(`Hello AireadFan Renhao`) 进行 md5 摘要，得到q1(``)，然后对q1用A私钥加密得到MQ，再将它们发送给B;
  2. B将收到的大量信息M进行 md5 摘要得到q2，再使用A公钥解密MQ得到q1, 如果 q1 等于 q2，则确定该信息没有被篡改。

## References
- [http://www.cnblogs.com/happinessCodes/archive/2010/07/27/1786404.html](http://www.cnblogs.com/happinessCodes/archive/2010/07/27/1786404.html)

